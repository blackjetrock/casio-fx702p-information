////////////////////////////////////////////////////////////////////////////////
//
// Casio FX702P RAM replacement
//
// Emulates four uPD444G RAM chips.
// Four CE lines, a WE and 10 address lines.
// Four bit data
//
////////////////////////////////////////////////////////////////////////////////

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/clocks.h"
#include "hardware/gpio.h"
#include "hardware/flash.h"
#include "pico/multicore.h"
#include "pico/bootrom.h"

#include "f_util.h"

#include "ff.h"
#include "ff_stdio.h"
#include "hw_config.h"
#include "my_debug.h"
#include "rtc.h"
#include "sd_card.h"

// Use this if breakpoints don't work
#define DEBUG_STOP {volatile int x = 1; while(x) {} }

#define TEST_SINGLE_ADDRESS  0
#define TEST_ALL_ADDRESS     0
#define INIT_RAM             1
#define TRACE_ONLY           0
#define LOAD_RAM             0

#define BYTE_TO_ROM_DATA(ADDRESS, DATA)       rom_data[(ADDRESS)*2+0] = ((0xFF ^(DATA)) & 0x0f) >> 0; rom_data[(ADDRESS)*2+1] = (((DATA) ^ 0xFF) & 0xf0) >> 4;

//-----------------------------------------------------------------------------
//
// ROM Emulator Flags

// OE pin used to switch data direction
// If 0 then DDIR_A15 used, under processor conrol

#define USE_OE_FOR_DATA_DIRECTION 1

// The address lines we are looking at

// Do we run emulation on second core?
#define EMULATE_ON_CORE1   1

// RAM chip is 4K
// Organised as 4k x 4 bits. We pak into bytes for storage in flash

#define ROM_SIZE  4*1024
#define ROM_SIZE_BYTES  (ROM_SIZE/2)

//--------------------------------------------------------------------------------
// Flash 
//

#define FLASH_SLOT_OFFSET (1024*1024)
uint8_t *flash_slot_contents   = (uint8_t *) (XIP_BASE + FLASH_SLOT_OFFSET);

// Flash slots

#define FLASH_SLOT_SIZE         4096
#define FLASH_SLOT_AREA_SIZE    (1000*1024)
#define FLASH_NUM_SLOTS         (FLASH_PROGRAM_SLOT_AREA_SIZE / FLASH_PROGRAM_SLOT_SIZE)

#define DISP_WIDTH              16

#define INVERT         1
#define DO_NOT_INVERT  0

uint8_t packed_ram[ROM_SIZE_BYTES];

//--------------------------------------------------------------------------------

#define ADDRESS_MASK 0x03FF

#define RAM_CE_SIZE  1024

// Map from memory space to ROM address space
#define MAP_ROM(X) (X & ADDRESS_MASK)

volatile uint8_t rom_data[ROM_SIZE] =
  {
   // ASSEMBLER_EMBEDDED_CODE_START

   // ASSEMBLER_EMBEDDED_CODE_END
  };

uint8_t rom_data_load[ROM_SIZE/2] =
  {
   0x43, 0x4E, 0x4B, 0x4B, 0x40, 0x51, 0x0F, 0x55, 0x40, 0x51, 0x48, 0x40, 0x41, 0x4B, 0x44, 0x41, 0x4B, 0x44, 0x14, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x1C, 0x14, 0x43, 0x4E, 0x4B, 0x4B, 0x40, 0x51, 0x0F, 0x55, 0x40, 0x51, 0x48, 0x40, 0x41, 0x4B, 0x44, 0x14, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x43, 0x4E, 0x4B, 0x4B, 0x40, 0x51, 0x0F, 0x55, 0x40, 0x51, 0x48, 0x40, 0x41, 0x4B, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x00, 0x1C, 0x31, 0x32, 0x33, 0xFF, 0x20, 0x00, 0x96, 0x14, 0x47, 0x44, 0x4B, 0x4B, 0x4E, 0x14, 0xFF, 0x30, 0x00, 0x96, 0x59, 0xFF, 0x00, 0x10, 0x96, 0x14, 0x4B, 0x48, 0x4D, 0x44, 0x0F, 0x31, 0x30, 0x30, 0x30, 0x14, 0xFF, 0x00, 0x01, 0x47, 0x1C, 0x34, 0x35, 0xFF, 0x20, 0x01, 0x44, 0x1C, 0x34, 0x37, 0xFF, 0x00, 0x10, 0x96, 0x14, 0x4B, 0x48, 0x4D, 0x44, 0x31, 0x30, 0x30, 0x30, 0x14, 0xFF, 0x99, 0x99, 0x96, 0x14, 0x4B, 0x40, 0x52, 0x53, 0x0F, 0x4B, 0x48, 0x4D, 0x44, 0x14, 0xFF, 0xEA, 0x2A, 0x55, 0x55, 0x57, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00, 0x90, 0x99, 0x99, 0x09, 0x55, 0x40, 0x51, 0x0F, 0x58, 0x16, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x45, 0x45, 0x45, 0x05, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x43, 0x43, 0x43, 0x03, 0x00, 0x00, 0x40, 0x42, 0x42, 0x42, 0x42, 0x02, 0x00, 0x00, 0x40, 0x04, 0x01, 0x00, 0x00, 0x00, 0x22, 0x22, 0x02, 0x07, 0x01, 0x00, 0x10, 0x11, 0x11, 0x11, 0x01,
  };

//------------------------------------------------------------------------------


//
// The address lines (always inputs)
//
const int  A0_PIN  =  0;
const int  A1_PIN  =  1;
const int  A2_PIN  =  2;
const int  A3_PIN  =  3;
const int  A4_PIN  =  4;
const int  A5_PIN  =  5;
const int  A6_PIN  =  6;
const int  A7_PIN  =  7;
const int  A8_PIN  =  8;
const int  A9_PIN  =  9;

const int  D0_PIN = 10;
const int  D1_PIN = 11;
const int  D2_PIN = 12;
const int  D3_PIN = 13;

const int INPUT1_PIN   = 26;
const int INPUT0_PIN   = 27;

// 444 has a select pin and an write pin, both active low
const int CE0_PIN       = 14;
const int CE1_PIN       = 15;
const int CE2_PIN       = 16;
const int CE3_PIN       = 17;
const int CE4_PIN       = 18;

#define CE_MASK  0x0F

const int W_PIN       = 19;

// Arrays for setting GPIOs up
#define NUM_ADDR 10
#define NUM_DATA 4

#define DATA_MASK 0x0F

const int address_pins[NUM_ADDR] =
  {
   A0_PIN,
   A1_PIN,
   A2_PIN,
   A3_PIN,
   A4_PIN,
   A5_PIN,
   A6_PIN,
   A7_PIN,
   A8_PIN,
   A9_PIN,
  };

const int data_pins[NUM_DATA] =
  {
   D0_PIN,
   D1_PIN,
   D2_PIN,
   D3_PIN,
  };

////////////////////////////////////////////////////////////////////////////////

// Serial loop command structure

typedef void (*FPTR)(void);

typedef struct
{
  char key;
  char *desc;
  FPTR fn;
} SERIAL_COMMAND;

////////////////////////////////////////////////////////////////////////////////

// Prototypes

void serial_help(void);
void save_ram(int slotnum);
void unpack_ram(uint8_t *src);

////////////////////////////////////////////////////////////////////////////////

int keypress = 0;

int parameter = 0;
int address   = 0;

////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Put a value on the data out lines. Value is 4 LS bits of the rom array.

inline void set_data(BYTE data)
{
  int states;
  int dat = data & DATA_MASK;
  
  // Direct register access to make things faster
  sio_hw->gpio_set = (  dat  << D0_PIN);
  sio_hw->gpio_clr = ((dat ^ DATA_MASK) << D0_PIN);
}

// Only deals with DOUT pin
inline void set_data_inputs(void)
{
  sio_hw->gpio_oe_clr = (DATA_MASK << D0_PIN);
}

inline void set_data_outputs(void)
{
  sio_hw->gpio_oe_set = (DATA_MASK<<D0_PIN);
}


////////////////////////////////////////////////////////////////////////////////
//
// Set things up then sit in a loop waiting for the emulated device to
// be selected
//
////////////////////////////////////////////////////////////////////////////////

#define MAX_ADDR_TRACE 2000

volatile int trace_on = 0;
volatile int addr_trace_index = 0;
volatile uint16_t addr_trace[MAX_ADDR_TRACE];
volatile uint8_t  data_trace[MAX_ADDR_TRACE];
volatile uint8_t    ce_trace[MAX_ADDR_TRACE];

volatile uint8_t  flag_trace[MAX_ADDR_TRACE];
volatile unsigned int number_ce_assert = 0;

#define FLAG_WRITE 1
#define FLAG_READ  2

////////////////////////////////////////////////////////////////////////////////
//
// Emulate a RAM chip
//
////////////////////////////////////////////////////////////////////////////////

#define EM_USB 0


void ram_emulate(void)
{
  //printf("\nEmulating RAM...");

  irq_set_mask_enabled( 0xFFFFFFFF, 0 );

  while(1)
    {
      uint32_t gpio_states;
      BYTE db;
      unsigned int addr;
      
      // We look for CE low
      if( ((gpio_states = sio_hw->gpio_in) & (CE_MASK << CE0_PIN)) == (CE_MASK << CE0_PIN) )
      	{
	  // S high, we are not selected
	  // Data lines inputs
	  set_data_inputs();
      	}
      else
      	{
	  // CE low, we are selected

	  // Get the select number
	  int selbits = (gpio_states & (CE_MASK << CE0_PIN)) >> CE0_PIN;
	  int selnum = 4;

	  switch(selbits)
	    {
	    case 0x0e:
	      selnum = 0;
	      break;

	    case 0x0D:
	      selnum = 1;
	      break;

	    case 0x0B:
	      selnum = 2;
	      break;

	    case 0x07:
	      selnum = 3;
	      break;
	    }

#if EM_USB
	  printf("\nSEL %d", selnum);
#endif
	  // We have to monitor W for a write pulse
	  // if we see it then we write the data on the rising edge of W
	  // While W is high we treat this as a read and present data

	  while(1)
	    {
	      gpio_states = sio_hw->gpio_in;

	      addr = ADDRESS_MASK ^ ((gpio_states >> A0_PIN) & ADDRESS_MASK);
	      
	      // Is this a read or a write?
	      if( (gpio_states & ( 1<< W_PIN))==0 )
		{

		  // Write
		  // data lines inputs
		  set_data_inputs();
		  
		  // Wait for W to go high then latch data

		  while( ((gpio_states = sio_hw->gpio_in) & (1 << W_PIN))==0 )
		    {
		    }
		  
		  // We have 4 bits of data to store, they are read from the Dn pins
		  rom_data[addr+selnum*RAM_CE_SIZE] = ((gpio_states & (DATA_MASK << D0_PIN))>>D0_PIN);

		  if( trace_on )
		    {
		      ce_trace[addr_trace_index] = selnum;
		      addr_trace[addr_trace_index] = addr;
		      data_trace[addr_trace_index] = rom_data[addr+selnum*RAM_CE_SIZE];
		      flag_trace[addr_trace_index] = FLAG_WRITE;
		      addr_trace_index++;
		      if( addr_trace_index == MAX_ADDR_TRACE )
			{
			  trace_on = 0;
			}
		      
		      addr_trace_index = addr_trace_index % MAX_ADDR_TRACE;
		    }
		  
		  while( ((gpio_states = sio_hw->gpio_in) & (CE_MASK << CE0_PIN)) != (CE_MASK << CE0_PIN) )
		    {
		    }

#if EM_USB
		  printf("\nWR %04X %01X", addr, (gpio_states & (DATA_MASK << D0_PIN))>>D0_PIN);
#endif
		}
	      else
		{

		  // Read
		  // If we are tracing then we sample the read value for tracing
		  
		  // make DOUT an output
#if !TRACE_ONLY		  
		  set_data_outputs();

		  // ROM emulation so always a read of us
		  // get address
		  //addr = (gpio_states >> A0_PIN) & ADDRESS_MASK;


		  // Get data and present it on bus (single bit)
		  set_data(rom_data[addr+selnum*RAM_CE_SIZE]);
#endif	  
		  if( trace_on )
		    {
		      ce_trace[addr_trace_index] = selnum;
		      addr_trace[addr_trace_index] = addr;
#if TRACE_ONLY
		 
		      data_trace[addr_trace_index] =  ((gpio_states & (DATA_MASK << D0_PIN))>>D0_PIN);
#else
		      data_trace[addr_trace_index] = rom_data[addr+selnum*RAM_CE_SIZE];
#endif
		      flag_trace[addr_trace_index] = FLAG_READ;
		      addr_trace_index++;
		      if( addr_trace_index == MAX_ADDR_TRACE )
			{
			  trace_on = 0;
			}
		      
		      addr_trace_index = addr_trace_index % MAX_ADDR_TRACE;

		    }
		  
		  while( ((gpio_states = sio_hw->gpio_in) & (CE_MASK << CE0_PIN)) != (CE_MASK << CE0_PIN) )
		    {
		    }
		  
#if EM_USB
		  printf("\nRD %04X %01X", addr, rom_data[addr+selnum*RAM_CE_SIZE]);
#endif		  
		  //set_data(0xF8);
		}

	      if( ((gpio_states = sio_hw->gpio_in) & (CE_MASK << CE0_PIN)) == (CE_MASK << CE0_PIN) )
		//if( gpio_states & (1 << CE_PIN) )
		{
		  // S gone high, exit the loop
		  // Delay for 100ns or so as the real 4044 does this
		  // and data is available for up to 100ns after CE rises.
#if 1
		  for(volatile int d=0; d<100; d++)
		    {
		    }
#endif		  
		  set_data_inputs();
#if EM_USB
		  printf("\nDesel");
#endif
		  break;
		}

	    }
#if 0	  
	  // Trace address
	  if( addr == 3 )
	    {
	      trace_on = 1;
	    }
	  
	  if( trace_on)
	    {
	      if( addr_trace_index < MAX_ADDR_TRACE )
		{
		  int tv = addr;
		  if( addr_trace[addr_trace_index] == tv )
		    {
		    }
		  else
		    {
		      addr_trace_index++;
		      addr_trace[addr_trace_index] = tv;
		    }
		  //addr_trace_index %= MAX_ADDR_TRACE;
		  
		}
	    }
	  number_ce_assert++;

#endif
#if 1
	  
	  // Wait for CE to be de-asserted
	  while(1)
	    {
	      // S high, we are not selected
	      // data lines inputs
	      gpio_states = sio_hw->gpio_in;
	      //printf("\nWAIT %08X", gpio_states);
	      //printf("  %02X", gpio_get(CE_PIN));
	      // We look for S
	      if( (gpio_states & (CE_MASK << CE0_PIN)) == (CE_MASK << CE0_PIN) )
		//if( gpio_states & (1 << CE_PIN) )
		{
		  // S high, we are not selected
		  // data lines inputs
		  set_data_inputs();
		  //printf("\nDONE WAIT");
		  break;
		}
	    }
#endif
	}
    }
}

void set_gpio_input(int gpio_pin)
{
  gpio_init(gpio_pin);
  gpio_set_dir(gpio_pin, GPIO_IN);
  gpio_set_pulls(gpio_pin, 0, 0);
}

void set_gpio_output(int gpio_pin)
{
  gpio_init(gpio_pin);
  gpio_set_dir(gpio_pin, GPIO_OUT);
}

////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////

// Displays the 702P memory

char code_to_ascii[256] =
  {
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', '?', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   '+', '-', '*', '/', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', ' ', ' ', ' ', ' ', ' ', 
   'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
   'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 
  };
  
char to_ascii(int ch)
{
  return(code_to_ascii[ch]);
}


#define NIBBLE(XXX) ((XXX & 0xF) ^ 0xF)
#define BYTE_WIDTH   32

void cli_dump_memory(void)
{
  printf("\n\n");
  char ascii[BYTE_WIDTH];
  char bc[10] = " ";
  char chr;
  
  for(int i=0; i<1024*4; i+=2)
    {
      if( (i % (BYTE_WIDTH * 2)) == 0 )
	{
	  if( i != 0 )
	    {
	      printf(" %s", ascii);
	      ascii[0] = '\0';
	    }
	  
	  printf("\n%04X: ", i/2);
	}
      
      printf(" %01X%01X", NIBBLE(rom_data[i+1]), NIBBLE(rom_data[i]));
      chr = NIBBLE(rom_data[i+1]) * 16 + NIBBLE(rom_data[i]);
      if( isprint(chr) )
	{
	  bc[0] = to_ascii(chr);
	}
      else
	{
	  bc[0] = '.';
	}
      strcat(ascii, bc);
    }

  printf(" %s", ascii);
  ascii[0] = '\0';

  printf("\n");
}


// Another digit pressed, update the parameter variable
void cli_digit(void)
{
  parameter *= 10;
  parameter += keypress-'0';
}

void cli_boot_mass(void)
{
  reset_usb_boot(0,0);
}

void cli_set_address(void)
{
  printf("\nSetting address to %04X", parameter);
  address = parameter;
  
}

void cli_zero_parameter(void)
{
  parameter = 0;
}

void cli_start_trace(void)
{
  trace_on = 1;
}

void cli_display_trace(void)
{
  char flg;
  
  for(int i=0; i<MAX_ADDR_TRACE; i++)
    {
      switch(flag_trace[i])
	{
	case FLAG_WRITE:
	  flg = 'W';
	  break;

	case FLAG_READ:
	  flg = 'R';
	  break;

	default:
	  flg = ' ';
	  break;
	}
      
      printf("\n%05d: %04X %01X %02X %c %c", i, addr_trace[i], ce_trace[i], data_trace[i], flg, (i==addr_trace_index)?'*':' ');
    }
}

void cli_write_byte(void)
{
  printf("\nWriting %02X to %02X...", parameter, address);

  BYTE_TO_ROM_DATA(address, parameter);
}

void cli_write_byte_16(void)
{
  for( int i=0; i<16; i++)
    {
      printf("\nWriting %02X to %02X...", parameter+i, address+i);
      
      BYTE_TO_ROM_DATA(address+i, parameter+i);
    }
}

void cli_save_ram(void)
{
  save_ram(parameter);
}

void cli_load_ram(void)
{
  printf("\nLoading program from flash slot %03d", parameter);

  // Get packed data
  memcpy(packed_ram, flash_slot_contents+parameter*FLASH_SLOT_SIZE, ROM_SIZE_BYTES);

  // Unpack it into emulation RAM
  unpack_ram(packed_ram);
  
  printf("\n");
}

// Erase a slot
void erase_slot(int n)
{
  flash_range_erase(FLASH_SLOT_OFFSET+n*FLASH_SLOT_SIZE, FLASH_SLOT_SIZE);
}

void cli_erase_program_slot(void)
{
  printf("\nErasing program slot %d...", parameter);
  erase_slot(parameter);
  printf("\ndone.\n");
}

void pack_ram_into(uint8_t *dest)
{
  for(int i=0; i<ROM_SIZE; i+=2)
    {
      *dest = (rom_data[i+1] & 0xF) * 16 + (rom_data[i] & 0xF);
      dest++;
    }
}

void unpack_ram(uint8_t *src)
{
  for(int i=0; i<ROM_SIZE_BYTES; i++)
    {
      rom_data[i*2+1] = ((*src) & 0xF0) >> 4;
      rom_data[i*2+0] = ((*src) & 0x0F) >> 0;
      src++;
    }
}


void save_ram(int slotnum)
{
  // pack the emulation RAM into bytes so we don't waste flash space
  pack_ram_into(packed_ram);
  
  // Erase slot
  erase_slot(slotnum);
  
  // Write the buffer back
  flash_range_program(FLASH_SLOT_OFFSET + (FLASH_SLOT_SIZE * slotnum), (uint8_t *) &(packed_ram[0]), ROM_SIZE);

  printf("\nData written\n");
  
}

// Displays (packed, as bytes) RAM
// Data can be inverted

void display_ram_at(uint8_t *ptr, int length, int invert)
{
  for(int i=0; i<length; i++)
    {
      if( (i % DISP_WIDTH) == 0 )
	{
	  printf("\n%04X: ", i);
	}
      if( invert)
	{
	  printf(" %02X", (*ptr) ^ 0xFF);
	}
      else
	{
	  printf(" %02X", *ptr);
	}
      
      ptr++;
    }
}

void cli_display_program_slot(void)
{
  
  printf("\nSlot %d\n", parameter);

  // First dump in hex
  display_ram_at(flash_slot_contents+parameter*FLASH_SLOT_SIZE, ROM_SIZE_BYTES, INVERT);

  printf("\n\n");
}


////////////////////////////////////////////////////////////////////////////////
//
// Serial CLI Handling
//
////////////////////////////////////////////////////////////////////////////////

SERIAL_COMMAND serial_cmds[] =
  {
   {
    'h',
    "Serial command help",
    serial_help,
   },
   {
    '?',
    "Serial command help",
    serial_help,
   },
   {
    '!',
    "Boot to mass storage",
    cli_boot_mass,
   },
   {
    'L',
    "Load emulation RAM from flash slot",
    cli_load_ram,
   },
   {
    'S',
    "Save emulation RAM from flash slot",
    cli_save_ram,
   },
   {
    'a',
    "Set Address",
    cli_set_address,
   },
   {
    'E',
    "Erase program slot",
    cli_erase_program_slot,
   },
   {
    'D',
    "Display program slot",
    cli_display_program_slot,
   },
   {
    'w',
    "Write Byte",
    cli_write_byte,
   },
   {
    'W',
    "Write 16 bytes",
    cli_write_byte_16,
   },
   {
    'd',
    "Dump",
    cli_dump_memory,
   },
   {
    'z',
    "Zero parameter",
    cli_zero_parameter,
   },
   {
    'T',
    "Start trace",
    cli_start_trace,
   },
   {
    't',
    "Display trace",
    cli_display_trace,
   },
   {
    '0',
    "*Digit",
    cli_digit,
   },
   {
    '1',
    "*Digit",
    cli_digit,
   },
   {
    '2',
    "*Digit",
    cli_digit,
   },
   {
    '3',
    "*Digit",
    cli_digit,
   },
   {
    '4',
    "*Digit",
    cli_digit,
   },
   {
    '5',
    "*Digit",
    cli_digit,
   },
   {
    '6',
    "*Digit",
    cli_digit,
   },
   {
    '7',
    "*Digit",
    cli_digit,
   },
   {
    '8',
    "*Digit",
    cli_digit,
   },
   {
    '9',
    "*Digit",
    cli_digit,
   },

  };


void serial_help(void)
{
  printf("\n");
  
  for(int i=0; i<sizeof(serial_cmds)/sizeof(SERIAL_COMMAND);i++)
    {
      if( *(serial_cmds[i].desc) != '*' )
	{
	  printf("\n%c:   %s", serial_cmds[i].key, serial_cmds[i].desc);
	}
    }
}


void prompt(void)
{
  printf("\n(Parameter:%d (%04X) Address: %d (%04X)", parameter, parameter, address, address);
  printf("\n >");
}

void serial_loop()
{
  int  key;
  
  if( ((key = getchar_timeout_us(1000)) != PICO_ERROR_TIMEOUT))
    {
      for(int i=0; i<sizeof(serial_cmds)/sizeof(SERIAL_COMMAND);i++)
	{
	  if( serial_cmds[i].key == key )
	    {

	      keypress = key;
	      (*serial_cmds[i].fn)();
	      prompt();
	      break;
	    }
	}
    }
  else
    {
      // I have found that I need to send something if the serial USB times out
      // otherwise I get lockups on the serial communications.
      // So, if we get a timeout we send a spoace and backspace it. And
      // flush the stdio, but that didn't fix the problem but seems like a good idea.
      stdio_flush();
      printf(" \b");
    }
}

////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////

int main()
{

  //DEBUG_STOP;
  
  char line[80];

#if TEST_SINGLE_ADDRESS
  int count = 0;
  
  for (int i=0; i<NUM_ADDR; i++)
    {
      set_gpio_output(address_pins[i]);
    }

  while(1)
    {
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 0);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
      gpio_put(A0_PIN, 1);
    }

#endif

  
#if TEST_ALL_ADDRESS
  int count = 0;

  // Set all GPIOs as outputs
  
  for (int i=0; i<NUM_ADDR; i++)
    {
      set_gpio_output(address_pins[i]);
    }

    for (int i=0; i< NUM_DATA; i++)
    {
      set_gpio_output(data_in_pins[i]);
      set_gpio_output(data_out_pins[i]);
    }

  while(1)
    {
      
      for (int i=0; i<NUM_ADDR; i++)
	{
	  gpio_put(address_pins[i], count & (1 <<i));
	}

      for (int i=0; i<NUM_DATA; i++)
	{
	  gpio_put(data_out_pins[i], count & (1 <<i));
	}

      for (int i=0; i<NUM_DATA; i++)
	{
	  gpio_put(data_in_pins[i], count & (1 <<i));
	}
      count++;
    }

#endif


  
  //#define OVERCLOCK 135000
//#define OVERCLOCK 200000
#define OVERCLOCK 270000
//#define OVERCLOCK 360000

  #if OVERCLOCK > 270000
  /* Above this speed needs increased voltage */
  vreg_set_voltage(VREG_VOLTAGE_1_20);
  sleep_ms(1);
#endif

  /* Overclock */
  set_sys_clock_khz( OVERCLOCK, 1 );

  // Put stdio init here as it mucks up gpio0/1
  
  stdio_init_all();
    
  for (int i=0; i<NUM_ADDR; i++)
    {
      set_gpio_input(address_pins[i]);
    }

  for( int i=0; i< NUM_DATA; i++)
    {
      set_gpio_input(data_pins[i]);
    }
  
  set_gpio_input(CE0_PIN);
  set_gpio_input(CE1_PIN);
  set_gpio_input(CE2_PIN);
  set_gpio_input(CE3_PIN);
  set_gpio_input(CE4_PIN);
  set_gpio_input(W_PIN);

  multicore_launch_core1(ram_emulate);

  sleep_ms(2000);
  
  printf("\n\n");
  printf("\n/------------------------------\\");
  printf("\n| Casio FX702P uPD444G RAM     |");
  printf("\n| Replacement                  |");
  printf("\n/------------------------------/");
  printf("\n");
  
  printf("\nSetting GPIOs...");

#if INIT_RAM
  for(int i=0; i<1024*4; i++)
    {
      rom_data[i] = 0xFF;
    }
#endif

#if LOAD_RAM
  for(int i=0; i<ROM_SIZE/2; i++)
    {
      int ib = rom_data_load[i];

      BYTE_TO_ROM_DATA(i, ib);

      
    }
#endif
  
  // Sit in a loop and do nothing on this core for now.

  while(1)
    {
      serial_loop();
      
    }
  
}
